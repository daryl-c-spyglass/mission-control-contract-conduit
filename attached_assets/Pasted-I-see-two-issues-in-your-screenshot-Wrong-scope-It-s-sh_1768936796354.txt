I see two issues in your screenshot:

Wrong scope: It's showing photos for ALL properties (subject + comparables) when it should only show the subject property photos
Broken images: The photo thumbnails aren't loading (showing broken image icons)

Let me create a fix for both issues:

Replit Prompt: Fix AI Photo Selection - Subject Only + Fix Broken Images
Problems to Fix

Photo selection should only be for the SUBJECT property - not comparables
Images are broken - URLs not loading correctly


Part 1: Update PhotoSelectionPreview to Only Show Subject Property
tsx// client/src/components/cma/PhotoSelectionPreview.tsx

// Change the props interface - only accept subject property, not all properties
interface PhotoSelectionPreviewProps {
  subjectProperty: any;  // Changed from properties: any[]
  photoSource: 'aiSuggested' | 'custom' | 'first12' | 'all';
  photosPerProperty: number;
  onSelectionChange: (selectedPhotos: string[]) => void;  // Simplified - just array of URLs
}

export function PhotoSelectionPreview({
  subjectProperty,
  photoSource,
  photosPerProperty,
  onSelectionChange,
}: PhotoSelectionPreviewProps) {
  const [selectedPhotos, setSelectedPhotos] = useState<string[]>([]);
  const [aiRecommendations, setAiRecommendations] = useState<any[]>([]);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [insightsAvailable, setInsightsAvailable] = useState(true);

  // Get photos from subject property
  const photos = useMemo(() => {
    if (!subjectProperty) return [];
    return subjectProperty.photos || subjectProperty.images || [];
  }, [subjectProperty]);

  const propertyId = subjectProperty?.listingId || subjectProperty?.id;
  const propertyAddress = subjectProperty?.unparsedAddress?.split(',')[0] || 
                          subjectProperty?.address || 
                          'Subject Property';

  // Fetch AI recommendations when source is 'aiSuggested'
  useEffect(() => {
    if (photoSource === 'aiSuggested' && propertyId) {
      fetchAiRecommendations();
    } else if (photoSource === 'custom') {
      // For custom, start with empty selection
      setSelectedPhotos([]);
    } else {
      // For first12/all, auto-select
      autoSelectPhotos();
    }
  }, [photoSource, propertyId, photosPerProperty]);

  const autoSelectPhotos = () => {
    let selected: string[] = [];
    
    if (photoSource === 'first12') {
      selected = photos.slice(0, Math.min(photosPerProperty, 12));
    } else if (photoSource === 'all') {
      selected = photos.slice(0, photosPerProperty);
    }
    
    setSelectedPhotos(selected);
    onSelectionChange(selected);
  };

  const fetchAiRecommendations = async () => {
    if (!propertyId) return;
    
    setLoading(true);
    setError(null);
    
    try {
      // Check if property already has imageInsights
      if (subjectProperty.imageInsights?.images?.length > 0) {
        const topPhotos = getTopPhotos(subjectProperty.imageInsights.images, photos, photosPerProperty);
        setAiRecommendations(topPhotos);
        setInsightsAvailable(true);
        
        const selected = topPhotos.map((p: any) => p.url).filter(Boolean);
        setSelectedPhotos(selected);
        onSelectionChange(selected);
        setLoading(false);
        return;
      }
      
      // Fetch from API
      const response = await fetch(`/api/repliers/listing/${propertyId}/image-insights`);
      
      if (!response.ok) {
        throw new Error(`API returned ${response.status}`);
      }
      
      const data = await response.json();
      
      if (data.available && data.images?.length > 0) {
        setInsightsAvailable(true);
        const topPhotos = getTopPhotos(data.images, photos, photosPerProperty);
        setAiRecommendations(topPhotos);
        
        const selected = topPhotos.map((p: any) => p.url).filter(Boolean);
        setSelectedPhotos(selected);
        onSelectionChange(selected);
      } else {
        // Fallback - no insights available
        setInsightsAvailable(false);
        const fallback = photos.slice(0, photosPerProperty);
        setSelectedPhotos(fallback);
        onSelectionChange(fallback);
      }
      
    } catch (err) {
      console.error('Failed to fetch AI recommendations:', err);
      setError(err instanceof Error ? err.message : 'Failed to analyze photos');
      setInsightsAvailable(false);
      
      // Fallback to first photos
      const fallback = photos.slice(0, photosPerProperty);
      setSelectedPhotos(fallback);
      onSelectionChange(fallback);
    } finally {
      setLoading(false);
    }
  };

  // Get top photos based on Image Insights
  const getTopPhotos = (insights: any[], allPhotos: string[], count: number) => {
    const priorityOrder = [
      'front', 'exterior', 'facade',
      'kitchen', 
      'living room', 'living', 'family room',
      'pool', 'backyard', 'patio',
      'master bedroom', 'bedroom',
      'bathroom', 'master bath',
    ];
    
    const scored = insights.map((img, index) => {
      let score = 0;
      const classification = (img.classification?.imageOf || '').toLowerCase();
      
      // Quality score
      if (img.quality?.qualitative === 'excellent') score += 100;
      else if (img.quality?.qualitative === 'above average') score += 75;
      else if (img.quality?.qualitative === 'average') score += 50;
      
      // Numeric quality boost
      if (img.quality?.score) {
        score += (img.quality.score / 6) * 30;
      }
      
      // Classification priority
      for (let i = 0; i < priorityOrder.length; i++) {
        if (classification.includes(priorityOrder[i])) {
          score += (priorityOrder.length - i) * 5;
          break;
        }
      }
      
      // IMPORTANT: Map to actual photo URL from the photos array
      const photoUrl = img.url || allPhotos[img.originalIndex] || allPhotos[index];
      
      return { 
        ...img, 
        url: photoUrl,
        score, 
        originalIndex: index 
      };
    });
    
    return scored
      .filter(img => img.url)
      .sort((a, b) => b.score - a.score)
      .slice(0, count);
  };

  const togglePhotoSelection = (photoUrl: string) => {
    setSelectedPhotos(prev => {
      let updated: string[];
      
      if (prev.includes(photoUrl)) {
        updated = prev.filter(url => url !== photoUrl);
      } else if (prev.length < photosPerProperty) {
        updated = [...prev, photoUrl];
      } else {
        // Replace oldest
        updated = [...prev.slice(1), photoUrl];
      }
      
      onSelectionChange(updated);
      return updated;
    });
  };

  // Loading state
  if (loading) {
    return (
      <div className="bg-white dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
        <div className="flex flex-col items-center justify-center gap-3 py-8">
          <Loader2 className="w-6 h-6 animate-spin text-primary" />
          <span className="text-gray-500 dark:text-gray-400">Analyzing photos with AI...</span>
        </div>
      </div>
    );
  }

  // Don't render if not AI or custom source
  if (photoSource !== 'aiSuggested' && photoSource !== 'custom') {
    return null;
  }

  // No photos available
  if (photos.length === 0) {
    return (
      <div className="bg-white dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
        <div className="flex items-center gap-2 mb-4">
          <ImageIcon className="w-5 h-5 text-gray-400" />
          <span className="text-gray-500">No photos available for this property</span>
        </div>
      </div>
    );
  }

  return (
    <div className="bg-white dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
      {/* Header */}
      <div className="flex items-center gap-2 mb-2">
        {photoSource === 'aiSuggested' ? (
          <>
            <Sparkles className="w-5 h-5 text-yellow-500" />
            <h3 className="font-semibold text-gray-900 dark:text-white">AI Suggested Photos</h3>
            {insightsAvailable && (
              <Badge className="text-xs bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300">
                Repliers Image Insights
              </Badge>
            )}
          </>
        ) : (
          <>
            <ImageIcon className="w-5 h-5 text-gray-500" />
            <h3 className="font-semibold text-gray-900 dark:text-white">Custom Photo Selection</h3>
          </>
        )}
      </div>
      
      <p className="text-sm text-gray-500 dark:text-gray-400 mb-4">
        {photoSource === 'aiSuggested' 
          ? 'AI has selected the best quality photos based on image classification and quality scores.'
          : `Select up to ${photosPerProperty} photo(s) for the subject property.`
        }
      </p>

      {/* Subject Property Photos Only */}
      <div>
        <div className="flex items-center justify-between mb-3">
          <div>
            <h4 className="font-medium text-gray-900 dark:text-white text-sm">
              {propertyAddress}
            </h4>
            <span className="text-xs text-gray-500">
              {photos.length} available â€¢ {selectedPhotos.length}/{photosPerProperty} selected
            </span>
          </div>
        </div>
        
        <div className="grid grid-cols-6 gap-2">
          {photos.slice(0, 12).map((photo: string, idx: number) => {
            const isSelected = selectedPhotos.includes(photo);
            const aiRec = aiRecommendations.find((r: any) => r.url === photo || r.originalIndex === idx);
            const classification = aiRec?.classification?.imageOf;
            const quality = aiRec?.quality?.qualitative;
            
            return (
              <button
                key={idx}
                onClick={() => togglePhotoSelection(photo)}
                className={cn(
                  "relative aspect-square rounded-lg overflow-hidden border-2 transition-all bg-gray-100 dark:bg-gray-800",
                  isSelected 
                    ? "border-primary ring-2 ring-primary/20" 
                    : "border-transparent hover:border-gray-300 dark:hover:border-gray-600"
                )}
                title={classification || `Photo ${idx + 1}`}
              >
                <img 
                  src={photo} 
                  alt={classification || `Photo ${idx + 1}`}
                  className="w-full h-full object-cover"
                  loading="lazy"
                  onError={(e) => {
                    // Handle broken images - show placeholder
                    const target = e.target as HTMLImageElement;
                    target.style.display = 'none';
                    target.parentElement?.classList.add('flex', 'items-center', 'justify-center');
                    const placeholder = document.createElement('div');
                    placeholder.className = 'text-xs text-gray-400 text-center p-1';
                    placeholder.textContent = classification || `Photo ${idx + 1}`;
                    target.parentElement?.appendChild(placeholder);
                  }}
                />
                
                {/* Selection checkmark */}
                {isSelected && (
                  <div className="absolute top-1 right-1 w-5 h-5 bg-primary rounded-full flex items-center justify-center shadow">
                    <Check className="w-3 h-3 text-white" />
                  </div>
                )}
                
                {/* Classification label */}
                {classification && photoSource === 'aiSuggested' && (
                  <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-1">
                    <span className="text-[10px] text-white font-medium truncate block">
                      {classification}
                    </span>
                  </div>
                )}
                
                {/* Quality dot */}
                {quality && (
                  <div className={cn(
                    "absolute top-1 left-1 w-2 h-2 rounded-full",
                    quality === 'excellent' && "bg-green-500",
                    quality === 'above average' && "bg-blue-500",
                    quality === 'average' && "bg-yellow-500",
                  )} />
                )}
              </button>
            );
          })}
        </div>
      </div>
    </div>
  );
}

Part 2: Update Parent Component to Pass Only Subject Property
tsx// In CMAPresentationBuilder.tsx - Update how PhotoSelectionPreview is called

{/* Photo Preview Section - Only show for subject property */}
{(layoutSettings.photoSource === 'aiSuggested' || layoutSettings.photoSource === 'custom') && (
  <PhotoSelectionPreview 
    subjectProperty={subjectProperty}  // Only subject, not comparables
    photoSource={layoutSettings.photoSource}
    photosPerProperty={layoutSettings.photosPerProperty}
    onSelectionChange={(photos) => setSelectedSubjectPhotos(photos)}
  />
)}

Part 3: Fix Broken Image URLs in API Response
The broken images suggest the URL mapping is incorrect. Update the API endpoint:
typescript// server/routes.ts - Fix image URL mapping

app.get('/api/repliers/listing/:listingId/image-insights', async (req, res) => {
  try {
    const { listingId } = req.params;
    const apiKey = process.env.REPLIERS_API_KEY;
    
    if (!apiKey) {
      return res.status(500).json({ available: false, error: 'API key not configured', images: [] });
    }
    
    const response = await fetch(
      `https://api.repliers.io/listings/${listingId}`,
      {
        headers: {
          'REPLIERS-API-KEY': apiKey,
          'Content-Type': 'application/json',
        },
      }
    );
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('Repliers API error:', response.status, errorText);
      return res.status(response.status).json({ available: false, error: 'API error', images: [] });
    }
    
    const data = await response.json();
    
    // Get the photos array - check multiple possible field names
    const photos = data.photos || data.images || data.media?.photos || [];
    
    console.log(`Listing ${listingId}: Found ${photos.length} photos`);
    
    // Check if Image Insights is available
    if (data.imageInsights?.images && data.imageInsights.images.length > 0) {
      console.log(`Image Insights available: ${data.imageInsights.images.length} analyzed`);
      
      return res.json({
        available: true,
        images: data.imageInsights.images.map((insight: any, index: number) => {
          // CRITICAL: Map the insight to the actual photo URL
          const photoUrl = photos[index] || insight.url || insight.imageUrl;
          
          return {
            url: photoUrl,
            originalIndex: index,
            classification: {
              imageOf: insight.classification?.imageOf || insight.imageOf || null,
              prediction: insight.classification?.prediction || null,
              confidence: insight.classification?.confidence || null,
            },
            quality: {
              score: insight.quality?.score || insight.qualityScore || null,
              qualitative: insight.quality?.qualitative || insight.qualityLabel || null,
            },
          };
        }),
        // Also return the raw photos array for fallback
        photos: photos,
      });
    }
    
    // Fallback: No Image Insights
    console.log('No Image Insights, returning photos only');
    return res.json({
      available: false,
      images: photos.map((url: string, index: number) => ({
        url,
        originalIndex: index,
        classification: null,
        quality: null,
      })),
      photos: photos,
    });
    
  } catch (error) {
    console.error('Image insights error:', error);
    return res.status(500).json({ available: false, error: 'Server error', images: [] });
  }
});

Part 4: Debug - Log Photo URLs
Add this temporary debug to see what URLs are being returned:
typescript// Add to the component to debug
useEffect(() => {
  if (subjectProperty) {
    console.log('Subject Property:', subjectProperty.unparsedAddress);
    console.log('Photos array:', subjectProperty.photos?.slice(0, 3));
    console.log('Images array:', subjectProperty.images?.slice(0, 3));
  }
}, [subjectProperty]);
Check the browser console to see if:

Photos are actual URLs (https://...)
Or just indices/IDs that need to be converted


Summary of Changes
IssueFixShowing all propertiesChanged to only accept subjectProperty prop, not arrayBroken imagesFixed URL mapping in API response + added onError handlerPhoto URLs not correctAPI now returns both insights and raw photos array

Files to Modify

client/src/components/cma/PhotoSelectionPreview.tsx - Simplify to single property
client/src/pages/CMAPresentationBuilder.tsx - Pass only subjectProperty
server/routes.ts - Fix photo URL mapping in API response


Acceptance Criteria

 Only subject property photos shown (not comparables)
 Photo thumbnails load correctly
 AI classification labels appear on photos
 Selection works correctly (checkmarks appear)
 Broken images show graceful fallback
