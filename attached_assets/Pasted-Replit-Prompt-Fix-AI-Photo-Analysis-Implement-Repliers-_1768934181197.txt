Replit Prompt: Fix AI Photo Analysis - Implement Repliers Image Insights API
Problem
The "Analyzing photos with AI..." spinner runs indefinitely because the Image Insights API endpoint is missing or not working correctly.
Reference Documentation

Repliers API uses REPLIERS-API-KEY header for authentication
Image Insights returns imageInsights.images[] with classification and quality data
Quality scores: qualitative (excellent, above average, average) and numeric score
Classification: imageOf field contains room type (Kitchen, Living Room, Exterior, etc.)


Part 1: Create/Fix the Image Insights API Endpoint
typescript// server/routes.ts - Add or update this endpoint

import fetch from 'node-fetch';

// GET /api/repliers/listing/:listingId/image-insights
app.get('/api/repliers/listing/:listingId/image-insights', async (req, res) => {
  try {
    const { listingId } = req.params;
    const apiKey = process.env.REPLIERS_API_KEY;
    
    if (!apiKey) {
      console.error('REPLIERS_API_KEY not configured');
      return res.status(500).json({ 
        available: false, 
        error: 'API key not configured',
        images: [] 
      });
    }
    
    console.log(`Fetching image insights for listing: ${listingId}`);
    
    // Fetch listing with imageInsights from Repliers
    // Note: imageInsights may need to be enabled on your Repliers account
    const response = await fetch(
      `https://api.repliers.io/listings/${listingId}`,
      {
        method: 'GET',
        headers: {
          'REPLIERS-API-KEY': apiKey,
          'Content-Type': 'application/json',
        },
      }
    );
    
    if (!response.ok) {
      const errorText = await response.text();
      console.error('Repliers API error:', response.status, errorText);
      return res.status(response.status).json({ 
        available: false, 
        error: `Repliers API error: ${response.status}`,
        images: [] 
      });
    }
    
    const data = await response.json();
    
    // Check if Image Insights is available in the response
    if (data.imageInsights?.images && data.imageInsights.images.length > 0) {
      console.log(`Image Insights available: ${data.imageInsights.images.length} images analyzed`);
      
      const photos = data.photos || data.images || [];
      
      return res.json({
        available: true,
        images: data.imageInsights.images.map((insight: any, index: number) => ({
          url: photos[index] || insight.url,
          originalIndex: index,
          classification: {
            imageOf: insight.classification?.imageOf || null,
            prediction: insight.classification?.prediction || null,
            confidence: insight.classification?.confidence || null,
          },
          quality: {
            score: insight.quality?.score || null,
            qualitative: insight.quality?.qualitative || null, // 'excellent', 'above average', 'average', 'below average'
          },
        })),
      });
    }
    
    // Fallback: Image Insights not enabled or no data - return photos without insights
    console.log('Image Insights not available for this listing, returning basic photos');
    const photos = data.photos || data.images || [];
    
    return res.json({
      available: false,
      message: 'Image Insights not enabled on this account',
      images: photos.map((url: string, index: number) => ({
        url,
        originalIndex: index,
        classification: null,
        quality: null,
      })),
    });
    
  } catch (error) {
    console.error('Image insights fetch error:', error);
    return res.status(500).json({ 
      available: false,
      error: error instanceof Error ? error.message : 'Unknown error',
      images: [],
    });
  }
});

Part 2: Update PhotoSelectionPreview Component with Better Error Handling
tsx// client/src/components/cma/PhotoSelectionPreview.tsx

import React, { useState, useEffect } from 'react';
import { Sparkles, Check, Image as ImageIcon, Loader2, AlertCircle, RefreshCw } from 'lucide-react';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { cn } from '@/lib/utils';

interface PhotoSelectionPreviewProps {
  properties: any[];
  photoSource: 'aiSuggested' | 'custom' | 'first12' | 'all';
  photosPerProperty: number;
  onSelectionChange: (selections: Record<string, string[]>) => void;
}

export function PhotoSelectionPreview({
  properties,
  photoSource,
  photosPerProperty,
  onSelectionChange,
}: PhotoSelectionPreviewProps) {
  const [selections, setSelections] = useState<Record<string, string[]>>({});
  const [aiRecommendations, setAiRecommendations] = useState<Record<string, any[]>>({});
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [insightsAvailable, setInsightsAvailable] = useState(true);

  // Fetch AI recommendations when source is 'aiSuggested'
  useEffect(() => {
    if (photoSource === 'aiSuggested') {
      fetchAiRecommendations();
    } else {
      // For non-AI sources, auto-select based on settings
      autoSelectPhotos();
    }
  }, [photoSource, properties, photosPerProperty]);

  const autoSelectPhotos = () => {
    const autoSelections: Record<string, string[]> = {};
    
    properties.filter(Boolean).forEach(property => {
      const propertyId = property.listingId || property.id;
      const photos = property.photos || property.images || [];
      
      let selectedPhotos: string[] = [];
      
      if (photoSource === 'first12') {
        selectedPhotos = photos.slice(0, Math.min(photosPerProperty, 12));
      } else if (photoSource === 'all') {
        selectedPhotos = photos.slice(0, photosPerProperty);
      }
      
      autoSelections[propertyId] = selectedPhotos;
    });
    
    setSelections(autoSelections);
    onSelectionChange(autoSelections);
  };

  const fetchAiRecommendations = async () => {
    setLoading(true);
    setError(null);
    
    try {
      const recommendations: Record<string, any[]> = {};
      const validProperties = properties.filter(Boolean);
      let anyInsightsAvailable = false;
      
      for (const property of validProperties) {
        const propertyId = property.listingId || property.id;
        if (!propertyId) continue;
        
        // Check if property already has imageInsights in its data
        if (property.imageInsights?.images?.length > 0) {
          recommendations[propertyId] = getTopPhotos(
            property.imageInsights.images, 
            property.photos || [],
            photosPerProperty
          );
          anyInsightsAvailable = true;
          continue;
        }
        
        // Fetch from API
        try {
          const response = await fetch(`/api/repliers/listing/${propertyId}/image-insights`);
          
          if (!response.ok) {
            console.warn(`Failed to fetch insights for ${propertyId}: ${response.status}`);
            // Use fallback - just take first N photos
            const photos = property.photos || property.images || [];
            recommendations[propertyId] = photos.slice(0, photosPerProperty).map((url: string, idx: number) => ({
              url,
              originalIndex: idx,
              classification: null,
              quality: null,
            }));
            continue;
          }
          
          const data = await response.json();
          
          if (data.available && data.images?.length > 0) {
            anyInsightsAvailable = true;
            recommendations[propertyId] = getTopPhotos(
              data.images,
              property.photos || [],
              photosPerProperty
            );
          } else {
            // Fallback to first N photos
            const photos = property.photos || property.images || [];
            recommendations[propertyId] = photos.slice(0, photosPerProperty).map((url: string, idx: number) => ({
              url,
              originalIndex: idx,
              classification: null,
              quality: null,
            }));
          }
        } catch (fetchError) {
          console.error(`Error fetching insights for ${propertyId}:`, fetchError);
          // Fallback
          const photos = property.photos || property.images || [];
          recommendations[propertyId] = photos.slice(0, photosPerProperty).map((url: string, idx: number) => ({
            url,
            originalIndex: idx,
            classification: null,
            quality: null,
          }));
        }
      }
      
      setInsightsAvailable(anyInsightsAvailable);
      setAiRecommendations(recommendations);
      
      // Auto-select AI recommendations
      const autoSelections: Record<string, string[]> = {};
      for (const [propertyId, photos] of Object.entries(recommendations)) {
        autoSelections[propertyId] = photos.map((p: any) => p.url).filter(Boolean);
      }
      setSelections(autoSelections);
      onSelectionChange(autoSelections);
      
    } catch (error) {
      console.error('Failed to fetch AI recommendations:', error);
      setError(error instanceof Error ? error.message : 'Failed to analyze photos');
      // Fallback to first photos
      autoSelectPhotos();
    } finally {
      setLoading(false);
    }
  };

  // Get top photos based on Image Insights quality and classification
  const getTopPhotos = (insights: any[], allPhotos: string[], count: number) => {
    // Priority order for room types
    const priorityOrder = [
      'front', 'exterior', 'facade',
      'kitchen', 
      'living room', 'living', 'family room',
      'pool', 'backyard', 'patio',
      'master bedroom', 'bedroom',
      'bathroom', 'master bath',
      'dining', 'dining room',
    ];
    
    const scored = insights.map((img, index) => {
      let score = 0;
      const classification = (img.classification?.imageOf || '').toLowerCase();
      
      // Quality score (0-100 scale)
      if (img.quality?.qualitative === 'excellent') score += 100;
      else if (img.quality?.qualitative === 'above average') score += 75;
      else if (img.quality?.qualitative === 'average') score += 50;
      else if (img.quality?.qualitative === 'below average') score += 25;
      
      // Numeric quality score boost (typically 1.0-6.0)
      if (img.quality?.score) {
        score += (img.quality.score / 6) * 30;
      }
      
      // Classification priority score
      for (let i = 0; i < priorityOrder.length; i++) {
        if (classification.includes(priorityOrder[i])) {
          score += (priorityOrder.length - i) * 5;
          break;
        }
      }
      
      // Confidence boost
      if (img.classification?.confidence) {
        score += img.classification.confidence * 10;
      }
      
      return { 
        ...img, 
        url: img.url || allPhotos[index],
        score, 
        originalIndex: index 
      };
    });
    
    // Sort by score descending and take top N
    return scored
      .filter(img => img.url) // Only include images with valid URLs
      .sort((a, b) => b.score - a.score)
      .slice(0, count);
  };

  const togglePhotoSelection = (propertyId: string, photoUrl: string) => {
    setSelections(prev => {
      const current = prev[propertyId] || [];
      let updated: string[];
      
      if (current.includes(photoUrl)) {
        updated = current.filter(url => url !== photoUrl);
      } else if (current.length < photosPerProperty) {
        updated = [...current, photoUrl];
      } else {
        // Replace oldest selection
        updated = [...current.slice(1), photoUrl];
      }
      
      const newSelections = { ...prev, [propertyId]: updated };
      onSelectionChange(newSelections);
      return newSelections;
    });
  };

  // Loading state
  if (loading) {
    return (
      <div className="bg-white dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
        <div className="flex flex-col items-center justify-center gap-3 py-8">
          <Loader2 className="w-6 h-6 animate-spin text-primary" />
          <span className="text-gray-500 dark:text-gray-400">Analyzing photos with AI...</span>
          <span className="text-xs text-gray-400">Using Repliers Image Insights API</span>
        </div>
      </div>
    );
  }

  // Error state
  if (error) {
    return (
      <div className="bg-white dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
        <div className="flex flex-col items-center justify-center gap-3 py-8">
          <AlertCircle className="w-6 h-6 text-amber-500" />
          <span className="text-gray-700 dark:text-gray-300">Could not analyze photos</span>
          <span className="text-xs text-gray-500">{error}</span>
          <Button 
            variant="outline" 
            size="sm" 
            onClick={fetchAiRecommendations}
            className="mt-2"
          >
            <RefreshCw className="w-4 h-4 mr-2" />
            Retry
          </Button>
        </div>
      </div>
    );
  }

  // Don't render if not AI or custom source
  if (photoSource !== 'aiSuggested' && photoSource !== 'custom') {
    return null;
  }

  return (
    <div className="bg-white dark:bg-gray-900 rounded-lg border border-gray-200 dark:border-gray-700 p-6">
      <div className="flex items-center gap-2 mb-4">
        {photoSource === 'aiSuggested' ? (
          <>
            <Sparkles className="w-5 h-5 text-yellow-500" />
            <h3 className="font-semibold text-gray-900 dark:text-white">AI Suggested Photos</h3>
            {insightsAvailable ? (
              <Badge variant="secondary" className="text-xs bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300">
                Repliers Image Insights
              </Badge>
            ) : (
              <Badge variant="secondary" className="text-xs bg-amber-100 text-amber-700 dark:bg-amber-900 dark:text-amber-300">
                Using default selection
              </Badge>
            )}
          </>
        ) : (
          <>
            <ImageIcon className="w-5 h-5 text-gray-500" />
            <h3 className="font-semibold text-gray-900 dark:text-white">Custom Photo Selection</h3>
          </>
        )}
      </div>
      
      <p className="text-sm text-gray-500 dark:text-gray-400 mb-4">
        {photoSource === 'aiSuggested' 
          ? insightsAvailable
            ? 'AI has selected the best quality photos based on image classification and quality scores.'
            : 'Image Insights not available. Using first photos as default. You can manually adjust.'
          : `Select up to ${photosPerProperty} photo(s) per property.`
        }
      </p>

      <div className="space-y-6 max-h-96 overflow-y-auto">
        {properties.filter(Boolean).map((property) => {
          const propertyId = property.listingId || property.id;
          const photos = property.photos || property.images || [];
          const selectedPhotos = selections[propertyId] || [];
          const aiRecs = aiRecommendations[propertyId] || [];
          
          if (photos.length === 0) return null;
          
          return (
            <div key={propertyId} className="border-t border-gray-200 dark:border-gray-700 pt-4 first:border-t-0 first:pt-0">
              <div className="flex items-center justify-between mb-3">
                <div>
                  <h4 className="font-medium text-gray-900 dark:text-white text-sm">
                    {property.unparsedAddress?.split(',')[0] || property.address || 'Property'}
                  </h4>
                  <span className="text-xs text-gray-500">
                    {photos.length} available â€¢ {selectedPhotos.length}/{photosPerProperty} selected
                  </span>
                </div>
              </div>
              
              <div className="grid grid-cols-6 gap-2">
                {photos.slice(0, 12).map((photo: string, idx: number) => {
                  const isSelected = selectedPhotos.includes(photo);
                  const aiRec = aiRecs.find((r: any) => r.url === photo || r.originalIndex === idx);
                  const classification = aiRec?.classification?.imageOf;
                  const quality = aiRec?.quality?.qualitative;
                  
                  return (
                    <button
                      key={idx}
                      onClick={() => togglePhotoSelection(propertyId, photo)}
                      className={cn(
                        "relative aspect-square rounded-lg overflow-hidden border-2 transition-all",
                        isSelected 
                          ? "border-primary ring-2 ring-primary/20" 
                          : "border-transparent hover:border-gray-300 dark:hover:border-gray-600"
                      )}
                      title={classification ? `${classification} (${quality || 'unknown quality'})` : `Photo ${idx + 1}`}
                    >
                      <img 
                        src={photo} 
                        alt={classification || `Photo ${idx + 1}`}
                        className="w-full h-full object-cover"
                        loading="lazy"
                      />
                      
                      {/* Selection indicator */}
                      {isSelected && (
                        <div className="absolute top-1 right-1 w-5 h-5 bg-primary rounded-full flex items-center justify-center shadow-sm">
                          <Check className="w-3 h-3 text-white" />
                        </div>
                      )}
                      
                      {/* AI classification badge */}
                      {classification && photoSource === 'aiSuggested' && (
                        <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/80 to-transparent p-1">
                          <span className="text-[10px] text-white font-medium truncate block">
                            {classification}
                          </span>
                        </div>
                      )}
                      
                      {/* Quality indicator dot */}
                      {quality && photoSource === 'aiSuggested' && (
                        <div className={cn(
                          "absolute top-1 left-1 w-2 h-2 rounded-full",
                          quality === 'excellent' && "bg-green-500",
                          quality === 'above average' && "bg-blue-500",
                          quality === 'average' && "bg-yellow-500",
                          quality === 'below average' && "bg-red-500",
                        )} />
                      )}
                    </button>
                  );
                })}
              </div>
            </div>
          );
        })}
      </div>
      
      {/* Legend for AI mode */}
      {photoSource === 'aiSuggested' && insightsAvailable && (
        <div className="mt-4 pt-4 border-t border-gray-200 dark:border-gray-700">
          <div className="flex items-center gap-4 text-xs text-gray-500">
            <span className="font-medium">Quality:</span>
            <span className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-green-500" /> Excellent</span>
            <span className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-blue-500" /> Above Average</span>
            <span className="flex items-center gap-1"><span className="w-2 h-2 rounded-full bg-yellow-500" /> Average</span>
          </div>
        </div>
      )}
    </div>
  );
}

export default PhotoSelectionPreview;

Part 3: Check Environment Variable
Make sure REPLIERS_API_KEY is set in your .env file:
bash# .env
REPLIERS_API_KEY=your_repliers_api_key_here

Part 4: Debug Endpoint (Optional - to test if Image Insights is enabled)
typescript// Add temporary debug endpoint to test Repliers Image Insights
app.get('/api/debug/repliers-insights-check', async (req, res) => {
  try {
    const apiKey = process.env.REPLIERS_API_KEY;
    
    if (!apiKey) {
      return res.json({ 
        status: 'error', 
        message: 'REPLIERS_API_KEY not set in environment' 
      });
    }
    
    // Test with a known listing ID (replace with a real one from your MLS)
    const testListingId = req.query.listingId || 'ACT2572987';
    
    const response = await fetch(
      `https://api.repliers.io/listings/${testListingId}`,
      {
        headers: {
          'REPLIERS-API-KEY': apiKey,
          'Content-Type': 'application/json',
        },
      }
    );
    
    const data = await response.json();
    
    return res.json({
      status: 'success',
      listingId: testListingId,
      hasImageInsights: !!data.imageInsights?.images,
      imageInsightsCount: data.imageInsights?.images?.length || 0,
      photosCount: data.photos?.length || 0,
      sampleInsight: data.imageInsights?.images?.[0] || null,
      rawFields: Object.keys(data),
    });
    
  } catch (error) {
    return res.json({ 
      status: 'error', 
      message: error instanceof Error ? error.message : 'Unknown error' 
    });
  }
});
Test by visiting: /api/debug/repliers-insights-check?listingId=YOUR_LISTING_ID

Files to Create/Modify

server/routes.ts - Add/fix the image insights endpoint
client/src/components/cma/PhotoSelectionPreview.tsx - Update with better error handling
.env - Ensure REPLIERS_API_KEY is set


Acceptance Criteria

 "Analyzing photos with AI..." completes (doesn't hang forever)
 If Image Insights is available, photos show classification labels (Kitchen, Living Room, etc.)
 If Image Insights is NOT available, falls back to first N photos with warning badge
 Quality dots appear (green/blue/yellow) based on Repliers quality scores
 Error state shows retry button
 Selected photos show checkmark indicator
 Debug endpoint confirms whether Image Insights is enabled on your account


Troubleshooting
If Image Insights still doesn't work after implementing:

Check if enabled: Use the debug endpoint to see if imageInsights exists in API response
Contact Repliers: Image Insights may need to be enabled on your account separately
Fallback works: The component should gracefully fall back to selecting first photos